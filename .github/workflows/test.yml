name: Test

permissions:
  contents: read

on:
  pull_request:
    paths-ignore:
      - '**/*.md'
  push:
    branches:
      - main
    paths-ignore:
      - '**/*.md'
      - '**/*.png'
      - '**/*.gif'

jobs:
  tests-unit:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-go@v5
      with:
        go-version-file: go.mod
    - name: runs tests
      run: |
        make test-unit FLAGS=-coverprofile=coverage.txt
        cat coverage.txt
    - name: uploads coverage reselt
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: true
        flags: unit

  tests-integration-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
      - name: Cache Docker images
        uses: actions/cache@v4
        id: docker-cache
        with:
          path: /tmp/.docker
          key: ${{ runner.os }}-docker-images-${{ hashFiles('test/docker-compose.yml') }}
          restore-keys: |
            ${{ runner.os }}-docker-images-
      - name: Load Docker images from cache
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          if [ -f /tmp/.docker/images.tar ]; then
            docker load -i /tmp/.docker/images.tar
          fi
      - name: Pull Docker images
        run: |
          docker compose -f test/docker-compose.yml pull
      - name: Save Docker images to cache
        if: steps.docker-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/.docker
          # Get all images from docker-compose.yml and save them
          # Use a temporary file to store images list to avoid subshell issues
          docker compose -f test/docker-compose.yml config --images > /tmp/.docker/images_list.txt 2>/dev/null || true
          if [ -s /tmp/.docker/images_list.txt ]; then
            while IFS= read -r img || [ -n "$img" ]; do
              [ -z "$img" ] && continue
              filename=$(echo "$img" | tr '/:' '_' | tr -d ' ')
              docker save "$img" -o "/tmp/.docker/${filename}.tar" 2>/dev/null || true
            done < /tmp/.docker/images_list.txt
            # Combine all image tars into one compressed archive
            if ls /tmp/.docker/*.tar 1> /dev/null 2>&1; then
              cd /tmp/.docker && tar -czf images.tar.gz *.tar && rm -f *.tar images_list.txt && mv images.tar.gz images.tar
            fi
          fi
      - name: starts dependencies
        run: |
          mkdir -p test/output/otel
          sudo chmod 777 -R test/output/otel
          make test-deps
          sleep 3
          docker compose -f test/docker-compose.yml logs
      - name: installs ginkgo
        run: go install github.com/onsi/ginkgo/v2/ginkgo
      - name: run tests
        run: |
          make test-main FLAGS="-coverpkg=github.com/webhookx-io/webhookx/... --cover --coverprofile=coverage.txt"
          cat coverage.txt
      - name: print webhookx.log
        if: failure()
        run: |
          cat test/webhookx.log
      - name: upload coverage reselt
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true
          flags: integration

  tests-integration-o11:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
      - name: Cache Docker images
        uses: actions/cache@v4
        id: docker-cache
        with:
          path: /tmp/.docker
          key: ${{ runner.os }}-docker-images-${{ hashFiles('test/docker-compose.yml') }}
          restore-keys: |
            ${{ runner.os }}-docker-images-
      - name: Load Docker images from cache
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          if [ -f /tmp/.docker/images.tar ]; then
            docker load -i /tmp/.docker/images.tar
          fi
      - name: Pull Docker images
        run: |
          docker compose -f test/docker-compose.yml pull
      - name: Save Docker images to cache
        if: steps.docker-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/.docker
          # Get all images from docker-compose.yml and save them
          # Use a temporary file to store images list to avoid subshell issues
          docker compose -f test/docker-compose.yml config --images > /tmp/.docker/images_list.txt 2>/dev/null || true
          if [ -s /tmp/.docker/images_list.txt ]; then
            while IFS= read -r img || [ -n "$img" ]; do
              [ -z "$img" ] && continue
              filename=$(echo "$img" | tr '/:' '_' | tr -d ' ')
              docker save "$img" -o "/tmp/.docker/${filename}.tar" 2>/dev/null || true
            done < /tmp/.docker/images_list.txt
            # Combine all image tars into one compressed archive
            if ls /tmp/.docker/*.tar 1> /dev/null 2>&1; then
              cd /tmp/.docker && tar -czf images.tar.gz *.tar && rm -f *.tar images_list.txt && mv images.tar.gz images.tar
            fi
          fi
      - name: starts dependencies
        run: |
          mkdir -p test/output/otel
          sudo chmod 777 -R test/output/otel
          make test-deps
          sleep 3
          docker compose -f test/docker-compose.yml logs
      - name: install ginkgo
        run: go install github.com/onsi/ginkgo/v2/ginkgo
      - name: run tests
        run: |
          make test-o11 FLAGS="-coverpkg=github.com/webhookx-io/webhookx/... --cover --coverprofile=coverage.txt"
          cat coverage.txt
      - name: print webhookx.log
        if: failure()
        run: |
          cat test/webhookx.log
      - name: upload coverage reselt
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true
          flags: integration-o11
